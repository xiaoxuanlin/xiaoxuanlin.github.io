{"posts":[{"title":"双指针解决链表问题","text":"141.环形链表给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 解题思路：利用快慢指针的思想，慢指针slow每次走一步，快指针fast每次走两步，如果链表中有环，则快慢指针一定会相遇，此时slow = fast。如果链表中没有环，fast一定会指向null。 1234567891011121314public boolean hasCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return true; } } return false;} 142.环形链表Ⅱ给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表 解题思路：我们需要在141题的思路上进一步扩展。首先我们和上题一样判断slow和fast指针是否能够相遇。如果不相遇，则链表无环，直接返回null。当相遇时，我们需要进行进一步处理。 我们设入环的第一个节点到快慢指针相遇的节点长度为k，从头节点到快慢指针相遇的节点长度为m。 则从头节点到入环的第一个节点长度为m-k。此时fast指针在走m-k步就可以到入环的第一个节点。所以我们让slow重新指回头节点。slow和fast再次相遇的节点就是入环的第一个节点。 12345678910111213141516171819202122232425public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { break; } } if (fast != null &amp;&amp; fast.next != null) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } return null;} 160.相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 解题思路：我们设链表A的长度为a，链表B的长度为b，相交链表的长度为c。 让指针listA从headA节点出发走a下，走到null后，将指针指向headB继续走。 让指针listB从headB节点出发走b下，走到null后，将指针指向headA继续走。 当listA和listB相遇时，这个就是他们的相交节点。此时他们都走了a + b - c的长度。 如果没有相交节点，c = 0， 此时他们都走了a + b的长度，指针都指向null。 123456789101112public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode listA = headA; ListNode listB = headB; while (listA != listB) { listA = (listA != null) ? listA.next : headB; listB = (listB != null) ? listB.next : headA; } return listA;} 19.删除链表的倒数第N个结点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 解题思路：要删除倒数第n个结点，就需要找到倒数第n-1个结点。 设置快慢指针slow和fast。我们需要让slow指向第n-1个结点，就要让fast先走n-1步。 注意，因为要考虑特殊情况，当节点数量为1，我们需要删除头节点，就需要建立一个空节点作为新的头节点，fast和slow从空节点开始，就需要走n步。终结条件为fast为空或者fast.next为空。 1234567891011121314151617181920public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummyHead = new ListNode(); dummyHead.next = head; ListNode slow = dummyHead, fast = dummyHead; for (int i = 0; i &lt; n; i++) { fast = fast.next; } while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next; } slow.next = slow.next.next; return dummyHead.next;} 21.合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 解题思路：递归解法：对于递归解法，我们不要深入递归去考虑，只需要考虑某个时间的状态。 假设现在有两个节点，list1和list2。对于初始状态，如果list1或list2为空，则直接返回非空的那一个。 //我们先定义方法的意义和返回值 //定义这个方法可以得到合并后的结果 public ListNode mergeTwoLists(ListNode list1, ListNode list2) 如果两个节点都不为空，我们就需要将两个节点中较小的一个，指向已合并好的递归结果 1234567891011121314public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null || list2 == null) { return (list1 != null) ? list1 : list2; } if (list1.val &lt; list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; }} 迭代解法：用两个指针cur1，cur2分别指向list1，list2。用cur指针记录串联新的链表，用dummyHead记录新的头节点作为返回值。当cur1，cur2都不为空时，我们比较cur1和cur2的大小，cur指向较小的一个，并且让cur和较小的节点移动一位。 最后让cur指向非空的cur1或者cur2即可。 12345678910111213141516171819202122public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummyHead = new ListNode(); ListNode cur = dummyHead; ListNode cur1 = list1, cur2 = list2; while (cur1 != null &amp;&amp; cur2 != null) { if (cur1.val &lt; cur2.val) { cur.next = cur1; cur1 = cur1.next; } else { cur.next = cur2; cur2 = cur2.next; } cur = cur.next; } cur.next = (cur1 != null) ? cur1 : cur2; return dummyHead.next;} 23.合并K个升序链表给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 解题思路：我们可以把合并K个升序链表转化为合并两个有序链表的问题。回忆一下归并排序，在合并的时候，就是K个有序数组合并成一个有序数组。我们可以借助归并排序的思想。将合并K个升序链表转化为O（knlogk）的问题。 123456789101112131415161718192021222324252627282930public ListNode mergeKLists(ListNode[] lists) { return merge(lists, 0, lists.length - 1);}public ListNode merge(ListNode[] lists, int left, int right) { if (left &gt; right) { return null; } else if (left == right) { return lists[left]; } else { int mid = left + (right - left) / 2; return mergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right)); }}public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null || l2 == null) { return l1 != null ? l1 : l2; } if (l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } 86.分隔链表给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 解题思路:我们用两个节点cur1和cur2分别记录小于x的节点和大于或等于x的节点,用cur记录head节点。在用dummy1和dummy2记录分别的头节点。遍历head链表，最后令cur1.next指向dummy2.next即可。 1234567891011121314151617181920212223public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(); ListNode dummy2 = new ListNode(); ListNode cur1 = dummy1, cur2 = dummy2; ListNode cur = head; while (cur != null) { if (cur.val &lt; x) { cur1.next = cur; cur1 = cur1.next; } else { cur2.next = cur; cur2 = cur2.next; } cur = cur.next; } cur2.next = null; cur1.next = dummy2.next; return dummy1.next;} 876.链表的中间结点给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 解题思路使用快慢指针，slow和fast。fast每次走两步，slow每次走一步即可。 因为题目中说如果有两个中间结点，则返回第二个中间结点。所以无论链表的结点个数为单数还是复数，这种方法都可以返回正确结果。 123456789101112public ListNode middleNode(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow;}","link":"/2022/12/16/%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/"},{"title":"JVM概述和内存结构","text":"一、JVM概述定义： Java Virtual Machine - java程序的运行环境 （java二进制字节码的运行环境） 好处： 一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界越界检查 多态 (使用虚方法调用的方式实现多态) 比较： jre jdk jvm 常见的JVM： 二、内存结构 2.1 程序计数器 （Program Counter Register PCR） 定义：物理上用寄存器 作用：记住下一条jvm指令的执行地址 特点： 线程私有，每个线程维护一个程序计数器，随着线程创建而创建，销毁而销毁。 不会存在内存溢出，是一块较小的内存空间 2.2 虚拟机栈-Xss定义栈大小 定义： 每个线程运行时所需要的内存，称为虚拟机栈 每个栈由多个栈帧（Frame）（包含参数，局部变量，返回地址）组成，对应着每次方法调用所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 问题： 垃圾回收是否涉及栈内存？ ​ 垃圾回收只涉及堆内存，不涉及栈内存 栈内存分配越大越好吗？ ​ 并不是越大越好，内存空间是固定的，栈内存越大，可用线程数则越少 方法内的局部变量是否线程安全？ 12345678910111213141516171819202122232425262728// 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的// 如果是局部变量引用了对象，并逃离方法的作用方法，需要考虑线程安全//线程安全public static void m1() { StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString());}//线程不安全，可以将StringBuilder改为StringBufferpublic static void m2(StringBuilder sb) { sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString());}//线程不安全，因为它作为返回值逃离方法的作用范围。public static StringBuilder m2() { StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); return sb;} 2.2.1 栈内存溢出 栈帧过多导致内存溢出（错误的递归调用） 栈帧过大导致内存溢出（不常见） 2.2.2 线程运行诊断案例1：cpu占用过多 定位 用top定位哪个进程对cpu的占用过高 ps H -eo pid,tid,%cpu|grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高） jstack 进程id 可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行数 案例2：程序运行很长时间没有结果 2.3 本地方法栈调用本地方法时，给本地方法的运行提供内存空间 native方法：不是由java代码编写的方法。因为java代码存在限制，有时候不能够直接和操作系统进行交互。 举例：clone(), hashCode(), notify(), notifyall(), wait() 2.4 堆定义Heap 堆 通过new关键字，创建对象都会使用堆内存 特点 它是线程共享的，堆中对象都需要考虑线程安全的问题 有垃圾回收机制 展开：对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，比如String s = new String(“william”);会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。 堆内存溢出-Xmx定义堆内存大小 堆内存诊断 jps 查看当前系统有哪些java进程 jmap工具 查看堆内存占用情况 jmap -heap 进程id jconsole工具 图形界面的，多功能的检测工具，可以连续检测 jvirsualvm 2.5 方法区方法区定义： 方法区属于是 JVM 运行时数据区域的一块逻辑区域，是所有Java虚拟机线程共享的区域。当有多个线程都用到一个类的时候，而这个类还未被加载，则应该只有一个线程去加载类，让其他线程等待； 保存在着被加载过的每一个类的信息；这些信息由类加载器在加载类的时候，从类的源文件中抽取出来；static变量信息也保存在方法区中。 方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。jvm也可以允许用户和程序指定方法区的初始大小，最小和最大限制； 方法区在虚拟机开启时创建。 2.5.1 组成部分 2.5.2 方法区内存溢出 1.8以前会导致永久代内存溢出 1.8以后会导致元空间内存溢出 场景 Spring Mybatis 2.5.3运行时常量池 常量池：一张表，虚拟机指令根据这张常量表找到要执行的而类名、方法名、参数类型、字面量等信息 运行时常量池，常量池是*.class文件中的，当该类被加载时，它的常量池信息就会被放入运行时常量池，并把里面的符号地址变为真实地址。 2.5.4 StringTable1234567891011121314151617181920212223// StringTable [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;] hashtable结构，不能扩容// 常量池中的信息，都会被加载到运行时常量池中，这时a b ab 都是常量池中的符号，还没有变为java字符串对象// ldc #2 会把a符号变为&quot;a&quot;字符串对象// ldc #3 会把b符号变为&quot;b&quot;字符串对象// ldc #4 会把ab符号变为&quot;ab&quot;字符串对象String s1 = &quot;a&quot;; // 懒惰的，延迟加载String s2 = &quot;b&quot;;String s3 = &quot;a&quot; + &quot;b&quot;;String s4 = s1 + s2; // new StringBuilder.append(&quot;a&quot;).append(&quot;b&quot;).toString() -&gt; new String(&quot;ab&quot;)String s5 = &quot;ab&quot;;String s6 = s4.intern();System.out.println(s3 == s4); // false (s3在StringTable中，s4在堆中)System.out.println(s3 == s5); // true (javac在编译期间的优化，结果在编译器确定为ab)System.out.println(s3 == s6); // trueString x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;); // new String(&quot;cd&quot;)String x1 = &quot;cd&quot;; // &quot;cd&quot;x2.intern();//问：如果调换了【最后两行代码】的位置呢？如果是jdk1.6呢（复制一份放入常量池）？System.out.println(x1 == x2); // false (常量池 堆) true(堆和常量池 堆和常量池) false(常量池 堆) 2.5.5 StringTable特性 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是StringBuilder（1.8） 字符串常量拼接的原理是编译期间优化 可以用intern方法，主动将串池中还没有的字符串对象放入串池，会把串池的对象返回 1.8将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回 1.6将这个字符串对象尝试放入串池，如果有则不会放入，如果没有会把此对象复制一份，放入串池中，会把串池中的对象返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//1.8//[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]public static void main(String[] args) { String x = &quot;ab&quot;; String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // new String(&quot;ab&quot;) // 堆 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;) String s2 = s.intern();//将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回 System.out.println(s2 == x); // true System.out.println(s == x); // false }//1.8//[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]public static void main(String[] args) { String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // new String(&quot;ab&quot;) // 堆 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;) String s2 = s.intern();//将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回 String x = &quot;ab&quot;; System.out.println(s2 == x); // true System.out.println(s == x); // true }//1.8//[&quot;ab&quot;,&quot;a&quot;, &quot;b&quot;]public static void main(String[] args) { String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // new String(&quot;ab&quot;) // 堆 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;) String s2 = s.intern();//将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回 String x = &quot;ab&quot;; System.out.println(s2 == x); // true System.out.println(s == x); // true }//1.6//[&quot;ab&quot;,&quot;a&quot;, &quot;b&quot;]public static void main(String[] args) { String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // new String(&quot;ab&quot;) // 堆 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;) String s2 = s.intern();//将这个字符串对象尝试放入串池，如果有则不会放入，如果没有会把此对象复制一份，放入串池中，会把串池中的对象返回 String x = &quot;ab&quot;; System.out.println(s2 == x); // true System.out.println(s == x); // false } 2.5.6 StringTable位置JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。 JDK 1.7 为什么要将字符串常量池移动到堆中？ 主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。 2.5.7 StringTable 性能调优 -XX:StringTableSize=20000 调整桶个数 -XX:+PrintStringTableStatistics ​ StringTable 底层使用哈希表实现的，增加bucket的数量，就可以减少哈希碰撞，从而实现性能调优。 考虑将字符串对象是否入池 2.6 直接内存定义： 常见于NIO操作时，用于数据缓冲区 分配回收成本较高，但读写性能高 不受JVM内存回收管理 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。 JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制 2.6.1 分配和回收原理 使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法 ByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存。 传统io 使用直接内存 参考：https://www.bilibili.com/video/BV1yE411Z7AP P1 - P47 https://javaguide.cn/java/jvm/memory-area.html","link":"/2022/12/20/JVM%E6%A6%82%E8%BF%B0%E5%92%8C%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"},{"title":"JVM并发编程(上)","text":"一、进程与线程1.1 进程与线程1.1.1 进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例程序，也有的程序只能启动一个实例进程 1.1.2 线程 一个进程之内可以分为一到多个线程 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行 Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows中进程是不活动的，只是作为线程的容器。 1.1.3二者对比 进程基本上相互独立，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享 进程间通信较为复杂 同一台计算机的进程通信成为IPC（Inter-process communication） 不腰痛计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低 1.2 并发与并行并发（concurrent）：两个及两个以上的作业在同一时间段执行，操作系统中使用时间片轮转算法，从而实现微观串行，宏观并行。 并行（parallel）：两个及两个以上的作业在同一时刻段执行。 1.3 同步与异步同步：发出一个调用之后，在没有得到结果之前，该调用就不可以返回，一直等待。 异步：调用在发出之后，不用等待返回结果，该调用直接返回。 1.4 应用1.4.1 异步调用设计： 多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停… 结论： 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程 1.4.2 提高效率设计： 由多个线程独立同时计算，最后进行汇总。 结论： 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化 1.5 线程的生命周期和状态Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态： NEW: 初始状态，线程被创建出来但没有被调用 start() 。 RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。 BLOCKED ：阻塞状态，需要等待锁释放。 WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。 TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。 TERMINATED：终止状态，表示该线程已经运行完毕。 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换 NEW 线程刚被创建，但是还没有调用 start() 方法 RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行） BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述 TERMINATED 当线程代码运行结束 1.6 线程死锁指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些线程都将无法向前推进。 1.6.1 死锁产生的必要条件 互斥条件：在一段时间内某资源仅为一个线程所占有。 不可剥夺条件：线程所获得的资源在未使用完之前，不能被其他线程强行夺走，即只能由获得该资源的线程自己来释放 请求并保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 1.6.2 死锁预防 破坏互斥条件（不太可行） 破坏不可剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破环请求并保持条件：采用预先静态分配方法，一次性申请完它所需要的资源 破坏循环等待条件：采用顺序资源分配发。按某一顺序申请资源，释放资源则反序释放。 1.6.3 死锁避免 系统安全状态 银行家算法 二、Java线程2.1 创建和运行线程2.1.1 方法一：直接使用Thread12345678//创建线程对象Thread t = new Thread() { public void run() { // 要执行的任务 }};//启动线程t.start(); 2.1.2 方法二：使用 Runnable 配置 Thread把【线程】和【任务】（要执行的代码）分开 Thread代表线程 Runnable代表可线程执行的任务 12345678910//创建任务对象Runnable runnable = new Runnable() { public void run() { //要执行的任务 }};//创建线程对象Thread t = new Thread(runnable);//启动线程t.start(); lambda表达式 123456//创建任务对象Runnable task2 = () -&gt; log.debug(&quot;hello&quot;);//创建线程对象Thread t2 = new Thread(task2, &quot;t2&quot;);//启动线程t2.start(); 2.1.3 Thread与Runnable之间的关系 方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了 用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活 2.1.4 方法三：FutureTask 配合 ThreadFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况。 123456789101112//创建任务对象FutureTask&lt;Integer&gt; task3 = new FutureTask&lt;&gt;(() -&gt; { log.debug(&quot;hello&quot;); return 100;});// 参数1 是任务对象， 参数2 是县城名字new Thread(task3, &quot;t3&quot;).start();// 主线程阻塞，同步等待task执行完毕的结果Integer result = task3.get();log.debug(&quot;结果是：{}&quot;, result); 2.2 线程运行原理2.2.1 栈与栈帧每个线程启动，虚拟机就会为其分配一块内存。 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 2.2.2 线程上下文切换因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 线程的 cpu 时间片用完 垃圾回收 有更高优先级的线程需要运行 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 Context Switch 频繁发生会影响性能 2.3 常用API 方法名 static 功能说明 注意 start() 启动一个新线程，在新的线程运行 run 方法中的代码 start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException run() 新线程启动后会调用的方法 如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为 join() 等待线程运行结束 join(long n) 等待线程运行结束,最多等待 n 毫秒 getId() 获取线程长整型的 id id 唯一 getName() 获取线程名 setName(String) 修改线程名 getPriority() 获取线程优先级 setPriority(int) 修改线程优先级 java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率 getState() 获取线程状态 Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED isInterrupted() 判断是否被打断， 不会清除 打断标记 isAlive() 线程是否存活（还没有运行完毕） interrupt() 打断线程 如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除 打断标记 ；如果打断的正在运行的线程，则会设置 打断标记 ；park 的线程被打断，也会设置 打断标记 interrupted() static 判断当前线程是否被打断 会清除 打断标记 currentThread() static 获取当前正在执行的线程 sleep(long n) static 让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程 yield() static 提示线程调度器让出当前线程对CPU的使用 主要是为了测试和调试 2.4 start 与 run 直接调用 run 是在主线程中执行了 run，没有启动新的线程 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码 2.5 sleep 与 yield2.5.1 sleep 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 睡眠结束后的线程未必会立刻得到执行 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 sleep() 方法不会释放锁 2.5.2 yield 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 具体的实现依赖于操作系统的任务调度器 2.5.3 线程优先级 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用 2.6 join方法等待线程执行结束，应用在同步上。 12345678910111213141516static int r = 0;public static void main(String[] args) throws InterruptedException { test1();}private static void test1() throws InterruptedException { log.debug(&quot;开始&quot;); Thread t1 = new Thread(() -&gt; { log.debug(&quot;开始&quot;); sleep(1); log.debug(&quot;结束&quot;); r = 10; }); t1.start(); log.debug(&quot;结果为:{}&quot;, r); log.debug(&quot;结束&quot;);} 分析 因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10 而主线程一开始就要打印 r 的结果，所以只能打印出 r=0 解决方法： 用 join，加在 t1.start() 之后即可 如果用sleep，不好控制主线程等待的时间 如果用join(long n),则在等待n毫秒后停止等待。 2.7 interrupt 方法2.7.1 打断sleep，wait，join的线程这几个方法都会让线程进入阻塞状态 打断位于阻塞状态的线程，会清空打断状态 2.7.2 打断正常运行的线程打断正常运行的线程，不会清空打断状态 2.7.3 两阶段终止模式在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。 错误思路： 使用线程对象的stop（）方法停止线程 stop() 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其他线程将永远无法获取锁。 使用System.exit(int) 方法停止线程 这种做法会让整个程序都停止 正确做法： 2.7.3.1 利用isInterrupted123456789101112131415161718192021222324252627class TPInterrupt { private Thread thread; //启动监控线程 public void start() { while (true) { Thread current = Thread.currentThread(); if (current.isInterrupted()) { log.debug(&quot;料理后事&quot;); break; } try { Thread.sleep(1000); // 情况1 睡眠打断 log.debug(&quot;执行监控记录&quot;); // 情况2 正常打断 } catch (InterruptedException e) { //重新设置打断标记 thread.interrupt(); e.printStackTrace(); } } } //停止监控线程 public void stop() { thread.interrupt(); }} 2.7.3.2 利用停止标记1234567891011121314151617181920212223242526272829// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见class TPVolatile { private Thread thread; private volatile boolean stop = false; //启动监控线程 public void start() { while (true) { Thread current = Thread.currentThread(); if (stop) { log.debug(&quot;料理后事&quot;); break; } try { Thread.sleep(1000); // 情况1 睡眠打断 log.debug(&quot;执行监控记录&quot;); // 情况2 正常打断 } catch (InterruptedException e) { e.printStackTrace(); } } } //停止监控线程 public void stop() { stop = true; thread.interrupt(); }} 2.8 打断park线程park是 LockSupport类中的方法 1234// 暂停当前线程LockSupport.park(); // 恢复某个线程的运行LockSupport.unpark(暂停线程对象) 与 Object 的 wait &amp; notify 相比 wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必 park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify 打断park线程，不会清空打断状态 123456789101112private static void test3() throws InterruptedException { Thread t1 = new Thread(() -&gt; { log.debug(&quot;park...&quot;); LockSupport.park(); log.debug(&quot;unpark...&quot;); log.debug(&quot;打断状态：{}&quot;, Thread.currentThread().isInterrupted()); }, &quot;t1&quot;); t1.start(); sleep(0.5); t1.interrupt();} 如果打断标记已经是true，则park会失效， 可以使用 Thread.interrupted() 清楚打断状态 2.9 主线程与守护线程默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 1234567891011121314151617log.debug(&quot;开始运行...&quot;);Thread t1 = new Thread(() -&gt; { log.debug(&quot;开始运行...&quot;); sleep(2); log.debug(&quot;运行结束...&quot;);}, &quot;daemon&quot;);// 设置该线程为守护线程t1.setDaemon(true);t1.start(); sleep(1);log.debug(&quot;运行结束...&quot;);//输出08:26:38.123 [main] c.TestDaemon - 开始运行... 08:26:38.213 [daemon] c.TestDaemon - 开始运行... 08:26:39.215 [main] c.TestDaemon - 运行结束... 注意： 垃圾回收器就是一种守护线程，当我们的程序中不再有任何运行的线程，程序就不会再产生垃圾，垃圾回收器也就无事可做。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 Tomcat中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待他们处理完当前请求。 参考https://www.bilibili.com/video/BV16J411h7Rd P1 - P49 https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html","link":"/2022/12/20/JVM%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%8A/"},{"title":"第一章 设计模式七大原则","text":"1、设计模式的目的 代码重用性（相同功能的代码，不用多次编写） 可读性（编程规范性） 可扩展性（能够方便的添加新功能） 可靠性（增加新功能后，对原来的功能没有影响） 高内聚、低耦合 2、七大设计原则 单一职责原则 接口隔离原则 依赖倒转原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则 2.1 单一职责原则基本介绍：对类来说，一个类应该只负责一项职责。 注意事项和细节 降低类的复杂度，一个类只负责一项职责 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应该遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。 2.2 接口隔离原则基本介绍：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上 分析上图： 1.类A通过接口Interface1依赖类B，类C通过 接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口， 那么类B和类D必须去实现他们不需要的方法。 2.按隔离原则应当这样处理: 将接口Interface1拆分为独立的几个接口， 类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 接口Interface1中出现的方法，根据实际情况拆分为三个接口 2.3 依赖倒转原则基本介绍： 高层模块不应该依赖底层模块，二者都应该依赖其抽象。（例如Controller层调用的是Service，而不是ServiceImpl） 抽象不应该依赖细节，细节应该依赖抽象 依赖倒转原则的中心思想是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。 使用接口或抽象类的目的是制定好规范，而不涉及任何的具体操作，把展现细节的任务交给他们的实现类去完成。 注意事项和细节 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。（例如Service层，Dao层） 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。（多态） 继承时遵循里氏替换原则。 2.4 里氏替换原则基本介绍： 所有引用基类的地方必须能透明地使用其子类的对象。 继承会让两个类耦合性增强，在适当的情况下，可以通过聚合，组合，依赖来解决问题。 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。 解决方法： 我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。 2.5 开闭原则基本介绍： 对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。 在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。 遵循其他原则，以及使用设计模式的目的就是实现开闭原则。 想要达到这样的效果，我们需要使用接口和抽象类。 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。 2.6 迪米特法则基本介绍： 一个对象应该对其他对象保持最少的了解 类与类关系越密切，耦合度越大 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。对外除了提供的public方法，不对外泄露任何信息。 只与直接朋友通信 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。 举例：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。 2.7 合成复用原则合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 通常类的复用分为继承复用和合成复用两种。 继承复用虽然有简单和易实现的优点，但它也存在以下缺点： 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点： 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 对象间的耦合度低。可以在类的成员位置声明抽象。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。","link":"/2022/12/20/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"juc","slug":"juc","link":"/tags/juc/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"链表","slug":"leetcode/链表","link":"/categories/leetcode/%E9%93%BE%E8%A1%A8/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"jvm","slug":"java/jvm","link":"/categories/java/jvm/"},{"name":"并发编程","slug":"java/并发编程","link":"/categories/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}