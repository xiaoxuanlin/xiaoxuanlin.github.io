{"posts":[{"title":"双指针解决链表问题","text":"141.环形链表给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 解题思路：利用快慢指针的思想，慢指针slow每次走一步，快指针fast每次走两步，如果链表中有环，则快慢指针一定会相遇，此时slow = fast。如果链表中没有环，fast一定会指向null。 1234567891011121314public boolean hasCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return true; } } return false;} 142.环形链表Ⅱ给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表 解题思路：我们需要在141题的思路上进一步扩展。首先我们和上题一样判断slow和fast指针是否能够相遇。如果不相遇，则链表无环，直接返回null。当相遇时，我们需要进行进一步处理。 我们设入环的第一个节点到快慢指针相遇的节点长度为k，从头节点到快慢指针相遇的节点长度为m。 则从头节点到入环的第一个节点长度为m-k。此时fast指针在走m-k步就可以到入环的第一个节点。所以我们让slow重新指回头节点。slow和fast再次相遇的节点就是入环的第一个节点。 12345678910111213141516171819202122232425public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { break; } } if (fast != null &amp;&amp; fast.next != null) { slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; } return null;} 160.相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 解题思路：我们设链表A的长度为a，链表B的长度为b，相交链表的长度为c。 让指针listA从headA节点出发走a下，走到null后，将指针指向headB继续走。 让指针listB从headB节点出发走b下，走到null后，将指针指向headA继续走。 当listA和listB相遇时，这个就是他们的相交节点。此时他们都走了a + b - c的长度。 如果没有相交节点，c = 0， 此时他们都走了a + b的长度，指针都指向null。 123456789101112public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode listA = headA; ListNode listB = headB; while (listA != listB) { listA = (listA != null) ? listA.next : headB; listB = (listB != null) ? listB.next : headA; } return listA;} 19.删除链表的倒数第N个结点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 解题思路：要删除倒数第n个结点，就需要找到倒数第n-1个结点。 设置快慢指针slow和fast。我们需要让slow指向第n-1个结点，就要让fast先走n-1步。 注意，因为要考虑特殊情况，当节点数量为1，我们需要删除头节点，就需要建立一个空节点作为新的头节点，fast和slow从空节点开始，就需要走n步。终结条件为fast为空或者fast.next为空。 1234567891011121314151617181920public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummyHead = new ListNode(); dummyHead.next = head; ListNode slow = dummyHead, fast = dummyHead; for (int i = 0; i &lt; n; i++) { fast = fast.next; } while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next; } slow.next = slow.next.next; return dummyHead.next;} 21.合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 解题思路：递归解法：对于递归解法，我们不要深入递归去考虑，只需要考虑某个时间的状态。 假设现在有两个节点，list1和list2。对于初始状态，如果list1或list2为空，则直接返回非空的那一个。 //我们先定义方法的意义和返回值 //定义这个方法可以得到合并后的结果 public ListNode mergeTwoLists(ListNode list1, ListNode list2) 如果两个节点都不为空，我们就需要将两个节点中较小的一个，指向已合并好的递归结果 1234567891011121314public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null || list2 == null) { return (list1 != null) ? list1 : list2; } if (list1.val &lt; list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } else { list2.next = mergeTwoLists(list1, list2.next); return list2; }} 迭代解法：用两个指针cur1，cur2分别指向list1，list2。用cur指针记录串联新的链表，用dummyHead记录新的头节点作为返回值。当cur1，cur2都不为空时，我们比较cur1和cur2的大小，cur指向较小的一个，并且让cur和较小的节点移动一位。 最后让cur指向非空的cur1或者cur2即可。 12345678910111213141516171819202122public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummyHead = new ListNode(); ListNode cur = dummyHead; ListNode cur1 = list1, cur2 = list2; while (cur1 != null &amp;&amp; cur2 != null) { if (cur1.val &lt; cur2.val) { cur.next = cur1; cur1 = cur1.next; } else { cur.next = cur2; cur2 = cur2.next; } cur = cur.next; } cur.next = (cur1 != null) ? cur1 : cur2; return dummyHead.next;} 23.合并K个升序链表给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 解题思路：我们可以把合并K个升序链表转化为合并两个有序链表的问题。回忆一下归并排序，在合并的时候，就是K个有序数组合并成一个有序数组。我们可以借助归并排序的思想。将合并K个升序链表转化为O（knlogk）的问题。 123456789101112131415161718192021222324252627282930public ListNode mergeKLists(ListNode[] lists) { return merge(lists, 0, lists.length - 1);}public ListNode merge(ListNode[] lists, int left, int right) { if (left &gt; right) { return null; } else if (left == right) { return lists[left]; } else { int mid = left + (right - left) / 2; return mergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right)); }}public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null || l2 == null) { return l1 != null ? l1 : l2; } if (l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } 86.分隔链表给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 解题思路:我们用两个节点cur1和cur2分别记录小于x的节点和大于或等于x的节点,用cur记录head节点。在用dummy1和dummy2记录分别的头节点。遍历head链表，最后令cur1.next指向dummy2.next即可。 1234567891011121314151617181920212223public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(); ListNode dummy2 = new ListNode(); ListNode cur1 = dummy1, cur2 = dummy2; ListNode cur = head; while (cur != null) { if (cur.val &lt; x) { cur1.next = cur; cur1 = cur1.next; } else { cur2.next = cur; cur2 = cur2.next; } cur = cur.next; } cur2.next = null; cur1.next = dummy2.next; return dummy1.next;} 876.链表的中间结点给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 解题思路使用快慢指针，slow和fast。fast每次走两步，slow每次走一步即可。 因为题目中说如果有两个中间结点，则返回第二个中间结点。所以无论链表的结点个数为单数还是复数，这种方法都可以返回正确结果。 123456789101112public ListNode middleNode(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow;}","link":"/2022/12/16/%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/"},{"title":"JVM概述和内存结构","text":"一、JVM概述定义： Java Virtual Machine - java程序的运行环境 （java二进制字节码的运行环境） 好处： 一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界越界检查 多态 (使用虚方法调用的方式实现多态) 比较： jre jdk jvm 常见的JVM： 二、内存结构 2.1 程序计数器 （Program Counter Register PCR） 定义：物理上用寄存器 作用：记住下一条jvm指令的执行地址 特点： 线程私有，每个线程维护一个程序计数器，随着线程创建而创建，销毁而销毁。 不会存在内存溢出，是一块较小的内存空间 2.2 虚拟机栈-Xss定义栈大小 定义： 每个线程运行时所需要的内存，称为虚拟机栈 每个栈由多个栈帧（Frame）（包含参数，局部变量，返回地址）组成，对应着每次方法调用所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 问题： 垃圾回收是否涉及栈内存？ ​ 垃圾回收只涉及堆内存，不涉及栈内存 栈内存分配越大越好吗？ ​ 并不是越大越好，内存空间是固定的，栈内存越大，可用线程数则越少 方法内的局部变量是否线程安全？ 12345678910111213141516171819202122232425262728// 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的// 如果是局部变量引用了对象，并逃离方法的作用方法，需要考虑线程安全//线程安全public static void m1() { StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString());}//线程不安全，可以将StringBuilder改为StringBufferpublic static void m2(StringBuilder sb) { sb.append(1); sb.append(2); sb.append(3); System.out.println(sb.toString());}//线程不安全，因为它作为返回值逃离方法的作用范围。public static StringBuilder m2() { StringBuilder sb = new StringBuilder(); sb.append(1); sb.append(2); sb.append(3); return sb;} 2.2.1 栈内存溢出 栈帧过多导致内存溢出（错误的递归调用） 栈帧过大导致内存溢出（不常见） 2.2.2 线程运行诊断案例1：cpu占用过多 定位 用top定位哪个进程对cpu的占用过高 ps H -eo pid,tid,%cpu|grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高） jstack 进程id 可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行数 案例2：程序运行很长时间没有结果 2.3 本地方法栈调用本地方法时，给本地方法的运行提供内存空间 native方法：不是由java代码编写的方法。因为java代码存在限制，有时候不能够直接和操作系统进行交互。 举例：clone(), hashCode(), notify(), notifyall(), wait() 2.4 堆定义Heap 堆 通过new关键字，创建对象都会使用堆内存 特点 它是线程共享的，堆中对象都需要考虑线程安全的问题 有垃圾回收机制 展开：对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，比如String s = new String(“william”);会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。 堆内存溢出-Xmx定义堆内存大小 堆内存诊断 jps 查看当前系统有哪些java进程 jmap工具 查看堆内存占用情况 jmap -heap 进程id jconsole工具 图形界面的，多功能的检测工具，可以连续检测 jvirsualvm 2.5 方法区方法区定义： 方法区属于是 JVM 运行时数据区域的一块逻辑区域，是所有Java虚拟机线程共享的区域。当有多个线程都用到一个类的时候，而这个类还未被加载，则应该只有一个线程去加载类，让其他线程等待； 保存在着被加载过的每一个类的信息；这些信息由类加载器在加载类的时候，从类的源文件中抽取出来；static变量信息也保存在方法区中。 方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。jvm也可以允许用户和程序指定方法区的初始大小，最小和最大限制； 方法区在虚拟机开启时创建。 2.5.1 组成部分 2.5.2 方法区内存溢出 1.8以前会导致永久代内存溢出 1.8以后会导致元空间内存溢出 场景 Spring Mybatis 2.5.3运行时常量池 常量池：一张表，虚拟机指令根据这张常量表找到要执行的而类名、方法名、参数类型、字面量等信息 运行时常量池，常量池是*.class文件中的，当该类被加载时，它的常量池信息就会被放入运行时常量池，并把里面的符号地址变为真实地址。 2.5.4 StringTable1234567891011121314151617181920212223// StringTable [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;] hashtable结构，不能扩容// 常量池中的信息，都会被加载到运行时常量池中，这时a b ab 都是常量池中的符号，还没有变为java字符串对象// ldc #2 会把a符号变为&quot;a&quot;字符串对象// ldc #3 会把b符号变为&quot;b&quot;字符串对象// ldc #4 会把ab符号变为&quot;ab&quot;字符串对象String s1 = &quot;a&quot;; // 懒惰的，延迟加载String s2 = &quot;b&quot;;String s3 = &quot;a&quot; + &quot;b&quot;;String s4 = s1 + s2; // new StringBuilder.append(&quot;a&quot;).append(&quot;b&quot;).toString() -&gt; new String(&quot;ab&quot;)String s5 = &quot;ab&quot;;String s6 = s4.intern();System.out.println(s3 == s4); // false (s3在StringTable中，s4在堆中)System.out.println(s3 == s5); // true (javac在编译期间的优化，结果在编译器确定为ab)System.out.println(s3 == s6); // trueString x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;); // new String(&quot;cd&quot;)String x1 = &quot;cd&quot;; // &quot;cd&quot;x2.intern();//问：如果调换了【最后两行代码】的位置呢？如果是jdk1.6呢（复制一份放入常量池）？System.out.println(x1 == x2); // false (常量池 堆) true(堆和常量池 堆和常量池) false(常量池 堆) 2.5.5 StringTable特性 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是StringBuilder（1.8） 字符串常量拼接的原理是编译期间优化 可以用intern方法，主动将串池中还没有的字符串对象放入串池，会把串池的对象返回 1.8将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回 1.6将这个字符串对象尝试放入串池，如果有则不会放入，如果没有会把此对象复制一份，放入串池中，会把串池中的对象返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//1.8//[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]public static void main(String[] args) { String x = &quot;ab&quot;; String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // new String(&quot;ab&quot;) // 堆 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;) String s2 = s.intern();//将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回 System.out.println(s2 == x); // true System.out.println(s == x); // false }//1.8//[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]public static void main(String[] args) { String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // new String(&quot;ab&quot;) // 堆 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;) String s2 = s.intern();//将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回 String x = &quot;ab&quot;; System.out.println(s2 == x); // true System.out.println(s == x); // true }//1.8//[&quot;ab&quot;,&quot;a&quot;, &quot;b&quot;]public static void main(String[] args) { String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // new String(&quot;ab&quot;) // 堆 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;) String s2 = s.intern();//将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回 String x = &quot;ab&quot;; System.out.println(s2 == x); // true System.out.println(s == x); // true }//1.6//[&quot;ab&quot;,&quot;a&quot;, &quot;b&quot;]public static void main(String[] args) { String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // new String(&quot;ab&quot;) // 堆 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;) String s2 = s.intern();//将这个字符串对象尝试放入串池，如果有则不会放入，如果没有会把此对象复制一份，放入串池中，会把串池中的对象返回 String x = &quot;ab&quot;; System.out.println(s2 == x); // true System.out.println(s == x); // false } 2.5.6 StringTable位置JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。 JDK 1.7 为什么要将字符串常量池移动到堆中？ 主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。 2.5.7 StringTable 性能调优 -XX:StringTableSize=20000 调整桶个数 -XX:+PrintStringTableStatistics ​ StringTable 底层使用哈希表实现的，增加bucket的数量，就可以减少哈希碰撞，从而实现性能调优。 考虑将字符串对象是否入池 2.6 直接内存定义： 常见于NIO操作时，用于数据缓冲区 分配回收成本较高，但读写性能高 不受JVM内存回收管理 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。 JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制 2.6.1 分配和回收原理 使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法 ByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存。 传统io 使用直接内存 参考：https://www.bilibili.com/video/BV1yE411Z7AP P1 - P47 https://javaguide.cn/java/jvm/memory-area.html","link":"/2022/12/20/JVM%E6%A6%82%E8%BF%B0%E5%92%8C%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"链表","slug":"leetcode/链表","link":"/categories/leetcode/%E9%93%BE%E8%A1%A8/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"jvm","slug":"java/jvm","link":"/categories/java/jvm/"}],"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}